//SourceUnit: TronFpro.sol

pragma solidity >=0.4.22 <0.6.0;
/*

  _____                          _____   ____                 
 |_   _|  _ __    ___    _ __   |  ___| |  _ \   _ __    ___  
   | |   | '__|  / _ \  | '_ \  | |_    | |_) | | '__|  / _ \ 
   | |   | |    | (_) | | | | | |  _|   |  __/  | |    | (_) |
   |_|   |_|     \___/  |_| |_| |_|     |_|     |_|     \___/ 
                                                              

https://tronfpro.io/
*/
contract TronFPro { struct MemberInfo { uint userID; address payable referrer; address[] allReferrals; uint activeX3Levels; uint activeX4Levels; address uplineposition; } struct x3Details { bool isActive; uint enterred; mapping(uint => address[]) referrals; uint cycle; } struct x4Details { bool isActive; uint enterred; uint cycle; bool missedIncome; address payable firstupline; address payable uplineaccount; mapping(uint => mapping(uint => address payable)) slotAddress; mapping(uint => mapping(address => uint)) source; mapping(uint => address[]) accounts; mapping(uint => uint[]) slots; } struct DownlineInfo{ uint position; uint source; }mapping (address => MemberInfo) memberInfos; mapping(uint => mapping(uint => x3Details)) X3; mapping(uint => mapping(uint => x4Details)) X4;mapping(address => uint) public balance; mapping(address => uint) public x3Income; mapping(address => uint) public x4Income; address payable owner; uint public lastID = 2;uint public TotalTransactions; uint public MissedProfit; constructor() public { owner = msg.sender; for(uint i=1; i<=12; i++){ if(i== 1){ newMember(owner, 1, address(0), i, false, 0); }else{ newMember(owner, 1, address(0), i, true, 3); newMember(owner, 1, address(0), i, true, 4); } } } function registration(address payable uplineAddress) external payable { require(msg.value == 200 trx); uint packageLvl = 1; uint memberId = getUserId(msg.sender); require(memberId == 0);uint uplineUserId = getUserId(uplineAddress); require(uplineUserId > 0); TotalTransactions += msg.value; uint _entry = msg.value / 2; memberId = lastID++; newMember(msg.sender, memberId, uplineAddress, packageLvl, false, 0); address payable _referrerUpline = getUpline(uplineAddress); MemberInfo storage _uplineInfo = memberInfos[uplineAddress]; _uplineInfo.allReferrals.push(msg.sender); x3Details storage _accountX3 = X3[uplineUserId][packageLvl]; _accountX3.referrals[_accountX3.cycle].push(msg.sender);if(_accountX3.enterred == 2){ _accountX3.enterred = 0; _accountX3.cycle += 1; sendProfit(3, _referrerUpline, _entry, packageLvl); }else{ _accountX3.enterred += 1; sendProfit(3, uplineAddress, _entry, packageLvl); } x4Matrix(uplineAddress, msg.sender, packageLvl, _entry); }function upgrade(uint256 matrix) external payable { require(matrix == 3 || matrix == 4); require(msg.value >= 200 trx); uint memberId = getUserId(msg.sender); address payable _newAccount = msg.sender; require(memberId > 0); uint packageLvl = _getPackageLevel(msg.value); require(getActiveMatrix(matrix, _newAccount) == (packageLvl - 1)); require(packageLvl > 1); bool hasPackage = X3[memberId][packageLvl].isActive; if(matrix == 4){ hasPackage = X4[memberId][packageLvl].isActive; } require(!hasPackage); address payable _referrerAddress = getUpline(msg.sender); uint _referrerUserId = getUserId(_referrerAddress); newMember(_newAccount, memberId, _referrerAddress, packageLvl, true, matrix); if(matrix == 3){ address payable _referrerUplineAddress = getUpline(_referrerAddress); x3Details storage _referrerMatrix3Info = X3[_referrerUserId][packageLvl]; _referrerMatrix3Info.referrals[_referrerMatrix3Info.cycle].push(msg.sender); if(_referrerMatrix3Info.enterred >= 2){ _referrerMatrix3Info.enterred = 0; _referrerMatrix3Info.cycle += 1; sendProfit(3, _referrerUplineAddress, msg.value, packageLvl); }else{ _referrerMatrix3Info.enterred += 1; sendProfit(3, _referrerAddress, msg.value, packageLvl); } }else if(matrix == 4){ uint _x4Profit = msg.value; _referrerAddress = getActiveUpline(_newAccount, packageLvl); _referrerUserId = getUserId(_referrerAddress); x4Matrix(_referrerAddress, msg.sender, packageLvl, _x4Profit); } } function sendProfit(uint matrix, address payable _account, uint _profit, uint _packageLvl)internal{ if(_account != address(0)){ if(matrix == 3){ bool isLvlActive = isMatrixActive(matrix, _account, _packageLvl); if(isLvlActive){ _account.transfer(_profit); balance[_account] += _profit; x3Income[_account] += _profit; }else{ address payable _active = getActivex3Upline(_account, _packageLvl); _active.transfer(_profit); balance[_active] += _profit; x3Income[_active] += _profit; } }else{ _account.transfer(_profit); balance[_account] += _profit; x4Income[_account] += _profit; } }else{ owner.transfer(_profit); balance[owner] += _profit; } }function newMember(address _account, uint _memberId, address payable _uplineAddress, uint _packageLvl, bool isUpgrade, uint matrix) internal{ MemberInfo storage _memberInfo = memberInfos[_account]; x3Details storage _x3 = X3[_memberId][_packageLvl]; x4Details storage _x4 = X4[_memberId][_packageLvl]; if(!isUpgrade){ _memberInfo.referrer = _uplineAddress; _memberInfo.userID = _memberId; _x3.isActive = true; _memberInfo.activeX3Levels += 1; _x4.isActive = true; _memberInfo.activeX4Levels += 1; }else{ if(matrix == 3){ _x3.isActive = true; _memberInfo.activeX3Levels += 1; }else { _x4.isActive = true; _memberInfo.activeX4Levels += 1; } } }function x4Matrix(address payable _account ,address payable _newMember, uint _pkg, uint _profit) internal { uint _availPosition; uint _userId = getUserId(_account); x4Details storage _accountX4 = X4[_userId][_pkg]; _availPosition = getX4AvailableSlot(_account, _pkg, _accountX4.cycle); _accountX4.slotAddress[_accountX4.cycle][_availPosition] = _newMember; _accountX4.slots[_accountX4.cycle].push(_availPosition); _accountX4.source[_accountX4.cycle][_newMember] = 1; _accountX4.accounts[_accountX4.cycle].push(_newMember);_accountX4.enterred += 1; address payable _2ndUpline = getNetworkUpline(_account, _pkg);if(_accountX4.enterred >= 6){ _accountX4.enterred = 0; _accountX4.cycle += 1; if(_profit > 0){ _2ndUpline.transfer(_profit); balance[_2ndUpline] += _profit; x4Income[_2ndUpline] += _profit; } if(_2ndUpline != address(0)){ x4Matrix(_2ndUpline, _account, _pkg, 0); } }else{ if(_availPosition <= 2){ if(_profit > 0){ sendProfit(4, _2ndUpline, _profit, _pkg); } }else{ if(_profit > 0){ sendProfit(4, _account, _profit, _pkg); } } } uint _networktPosition = _getUplinePosition(_availPosition); if(_networktPosition > 0){ address payable _accountDownline = _accountX4.slotAddress[_accountX4.cycle][_networktPosition]; ProcessX4Downline(_accountDownline, _pkg, _newMember, _profit); }else{ setUpline(_newMember, _account, _pkg, _profit); if(_2ndUpline != address(0)){ ProcessX4Upline(_2ndUpline, _account, _newMember, _pkg); } } } function ProcessX4Downline(address payable _account, uint _pkg, address payable _newMember, uint _profit) internal{ setUpline(_newMember, _account, _pkg, _profit); uint _userId = getUserId(_account); x4Details storage _downlineMatrix = X4[_userId][_pkg]; uint _availSlot = _downlineMatrix.enterred + 1; _downlineMatrix.slotAddress[_downlineMatrix.cycle][_availSlot] = _newMember; _downlineMatrix.slots[_downlineMatrix.cycle].push(_availSlot); _downlineMatrix.source[_downlineMatrix.cycle][_newMember] = 2; _downlineMatrix.accounts[_downlineMatrix.cycle].push(_newMember); _downlineMatrix.enterred += 1; } function ProcessX4Upline(address payable _account, address _downline, address payable _newMember, uint _pkg)internal{ uint _userId = getUserId(_account); x4Details storage _topAccountMatrix = X4[_userId][_pkg]; uint _availSlot = _topAccountMatrix.enterred; uint _cycle = _topAccountMatrix.cycle; if(_availSlot > 0){ if(getMatrixSlotInfo(_account, _pkg, _cycle, 1) == _downline) { _availSlot = 3; if(getMatrixSlotInfo(_account, _pkg, _cycle, 3) != address(0)){ _availSlot = 4; } } else { _availSlot = 5; if(getMatrixSlotInfo(_account, _pkg, _cycle, 5) != address(0)){ _availSlot = 6; } } }else{ _availSlot = getX4AvailableSlot(_account, _pkg, _cycle); }_topAccountMatrix.slotAddress[_cycle][_availSlot] = _newMember; _topAccountMatrix.slots[_cycle].push(_availSlot); _topAccountMatrix.source[_cycle][_newMember] = 3; _topAccountMatrix.accounts[_cycle].push(_newMember); _topAccountMatrix.enterred += 1; if(_topAccountMatrix.enterred >= 6){ _topAccountMatrix.enterred = 0; _topAccountMatrix.cycle += 1; address payable nxtUpline = getNetworkUpline(_account, _pkg); if(nxtUpline != address(0)){ x4Matrix(nxtUpline, _account, _pkg, 0); } } }function _getUplinePosition(uint position)pure internal returns(uint){ uint _uplinePosition = 0; if(position == 3 || position == 4){ _uplinePosition = 1; }else if(position == 5 || position == 6){ _uplinePosition = 2; } return _uplinePosition; } function _getPackageLevel(uint _amount)pure internal returns(uint){ uint lvl = 0; if(_amount == 200 trx){ lvl = 2; }else if(_amount == 400 trx){ lvl = 3; }else if(_amount == 600 trx){ lvl = 4; }else if(_amount == 1000 trx){ lvl = 5; }else if(_amount == 1500 trx){ lvl = 6; }else if(_amount == 2000 trx){ lvl = 7; }else if(_amount == 3000 trx){ lvl = 8; }else if(_amount == 4000 trx){ lvl = 9; }else if(_amount == 5000 trx){ lvl = 10; }else if(_amount == 6000 trx){ lvl = 11; }else if(_amount == 7000 trx){ lvl = 12; }else if(_amount == 8000 trx){ lvl = 13; }else if(_amount == 10000 trx){ lvl = 14; }else if(_amount == 15000 trx){ lvl = 15; }else if(_amount == 30000 trx){ lvl = 16; } return lvl; } function setUpline(address newaccount, address payable uplineaccount, uint pkg, uint _profit) internal{ uint userId = getUserId(newaccount); x4Details storage _x4 = X4[userId][pkg]; _x4.uplineaccount = uplineaccount; if(pkg == 1 && _profit > 0){ _x4.firstupline = uplineaccount; } } function getNetworkUpline(address payable account, uint pkg)view internal returns (address payable upline){ uint userId = getUserId(account); return X4[userId][pkg].uplineaccount; } function getX4AvailableSlot(address _address, uint _packageLvl, uint _cycle)view internal returns(uint){ for(uint i=1; i<=6; i++){ address account = getMatrixSlotInfo(_address, _packageLvl, _cycle, i); if(account == address(0)){ return i; } } return 0; } function getAccountInfo(address _address) view public returns (uint userId, address directUpline) { return (memberInfos[_address].userID, memberInfos[_address].referrer); } function getUserId(address _address) view public returns (uint userId) { if(_address == owner){ return 1; } return (memberInfos[_address].userID); } function getUpline(address _address) view public returns (address payable upline) { return (memberInfos[_address].referrer); } function getMatrix3Info(uint userId, uint level) view public returns (bool isactive, uint occupiedslots, uint cyclecount) { x3Details storage _x3 = X3[userId][level]; return (_x3.isActive, _x3.enterred, _x3.cycle); } function getMatrix3Referrals(address _address,uint level, uint cycle) view public returns (address[] memory referrals) { uint userId = getUserId(_address); return (X3[userId][level].referrals[cycle]); } function getAllReferrals(address _address) view public returns (address[] memory referrals) { return (memberInfos[_address].allReferrals); } function getMatrix4Info(uint _userId, uint _level) view public returns (bool isactive, uint occupiedslots, uint cyclecount) { x4Details storage _x4 = X4[_userId][_level]; return (_x4.isActive, _x4.enterred, _x4.cycle); } function isMatrixActive(uint matrix, address _address, uint level) view internal returns (bool) { uint userId = getUserId(_address); if(matrix == 3){ return (X3[userId][level].isActive); } return (X4[userId][level].isActive); } function getMatrix4Referrals(address _address, uint level, uint cycle) view public returns (address[] memory referrals) { uint _memberId = getUserId(_address); x4Details storage _matrix4Info = X4[_memberId][level]; return _matrix4Info.accounts[cycle]; } function getMatrix4Slots(address _address, uint level, uint cycle) view public returns (uint[] memory slots) { uint _memberId = getUserId(_address); x4Details storage _matrix4Info = X4[_memberId][level]; return _matrix4Info.slots[cycle]; }function getMatrixSlotInfo(address _address, uint level, uint cycle, uint position) view internal returns (address payable account ) { uint _memberId = getUserId(_address); x4Details storage _matrix4Info = X4[_memberId][level]; return _matrix4Info.slotAddress[cycle][position];} function getMatrixSlotDetails(address _address, uint level, uint cycle, uint position) view public returns (address account, uint source) { uint _memberId = getUserId(_address); x4Details storage _matrix4Info = X4[_memberId][level]; address _addressx = _matrix4Info.slotAddress[cycle][position]; uint _source = getMatrixSourceType(_memberId, _addressx, level, cycle); return (_addressx, _source); } function getMatrixSourceType(uint _userID, address _address, uint level, uint cycle) view internal returns (uint sourceType) { x4Details storage _matrix4Info = X4[_userID][level]; return _matrix4Info.source[cycle][_address]; } function getActiveMatrix(uint matrix, address _address) view internal returns (uint lastlevel) { MemberInfo storage member = memberInfos[_address]; if(matrix == 3){ return member.activeX3Levels; }else { return member.activeX4Levels; } } function getActiveUpline( address payable account, uint _packageLvl) internal returns(address payable){ bool _isUplineActiveBox = false; address payable _uplineAccount; uint _uplineUserId; while(_isUplineActiveBox != true){ _uplineAccount = getUpline(account); account = _uplineAccount; _uplineUserId = getUserId(_uplineAccount); x4Details storage uplineX4 = X4[_uplineUserId][_packageLvl]; _isUplineActiveBox = uplineX4.isActive; if(_isUplineActiveBox == false){ uplineX4.missedIncome = true; } } return _uplineAccount; } function getActivex3Upline(address payable account, uint _packageLvl) view internal returns(address payable){ bool _isUplineActiveBox = false; address payable _uplineAccount; uint _uplineUserId; while(_isUplineActiveBox != true){ _uplineAccount = getUpline(account);MemberInfo storage uplineInfox = memberInfos[_uplineAccount]; _uplineUserId = uplineInfox.userID; account = uplineInfox.referrer; _isUplineActiveBox = X3[_uplineUserId][_packageLvl].isActive; } return _uplineAccount; } }