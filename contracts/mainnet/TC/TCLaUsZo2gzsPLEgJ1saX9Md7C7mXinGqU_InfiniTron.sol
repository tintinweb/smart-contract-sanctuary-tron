//SourceUnit: InfinityTron.sol

pragma solidity >=0.4.22 <0.6.0;
/*
  ___            __   _           _   _____                        
 |_ _|  _ __    / _| (_)  _ __   (_) |_   _|  _ __    ___    _ __  
  | |  | '_ \  | |_  | | | '_ \  | |   | |   | '__|  / _ \  | '_ \ 
  | |  | | | | |  _| | | | | | | | |   | |   | |    | (_) | | | | |
 |___| |_| |_| |_|   |_| |_| |_| |_|   |_|   |_|     \___/  |_| |_|
                                                                   
https://infinitron.io
*/

contract InfiniTron { struct MemberInfo { uint userID; uint datereg; address payable referrer; address payable[] allReferrals; uint totalRewardBonus; uint bonusID; uint[] rewardBonusIDs; uint activeX3Levels; uint activeX4Levels; uint pendingIncomeID; mapping(uint => mapping(uint => mapping(uint => PendingIncome))) pendingIncome; mapping (uint => uint) pendingIncomeLevel; mapping (uint => uint) pendingIncomeMatrix; } struct AX3Info { uint datereg; bool isActive; uint enterred; mapping(uint => address[]) referrals; uint cycle; } struct AX4Info { uint datereg; bool missedIncome; bool isActive; uint enterred; uint cycle; address payable origUpline; address payable uplineposition; mapping(uint => address[]) accounts; mapping(uint => uint[]) slots; mapping(uint => mapping(uint => address payable)) slotAddress; mapping(uint => mapping(address => uint)) source; } struct RewardInfo{ address account; uint totalDirect; uint bonusPrize; bool isWinner; } struct PendingIncome{ bool isActive; uint amount; uint dateAdded; } mapping(uint => address[]) rewardQualifiers; mapping(uint => address payable[]) rewardPoolWinners; mapping (address => MemberInfo) memberInfos; mapping(address => uint) public balance; mapping(address => uint) public x3balance; mapping(address => uint) public x4balance; mapping(uint => mapping(uint => AX3Info)) matrix3Infos; mapping(uint => mapping(uint => AX4Info)) matrix4Infos; mapping(uint => mapping(uint => RewardInfo)) rewardInfo; address payable owner; uint public lastID = 2; uint public rewardPool; uint public rewardCycle; uint public TotalTransactions; constructor() public { owner = msg.sender; rewardCycle = 1; for(uint i=1; i<=12; i++){ if(i== 1){ newMember(owner, 1, address(0), i, false, 0, 0); }else{ newMember(owner, 1, address(0), i, true, 3, 0); newMember(owner, 1, address(0), i, true, 4, 0); } } } function registration(address payable uplineAddress) external payable { require(msg.value == 200 trx); uint packageLvl = 1; address payable _sender = msg.sender; uint memberId = getUserId(_sender); require(memberId == 0); uint uplineUserId = getUserId(uplineAddress); require(uplineUserId > 0); uint _entry = msg.value; TotalTransactions += _entry; uint _profit = _entry / 2; addRewardQualifier(uplineAddress, uplineUserId);memberId = lastID++; newMember(_sender, memberId, uplineAddress, packageLvl, false, 0, _profit); MemberInfo storage _uplineInfo = memberInfos[uplineAddress]; _uplineInfo.allReferrals.push(_sender); processX3(uplineAddress, uplineUserId, packageLvl, _sender, _profit); processMatrix(uplineAddress, _sender, packageLvl, _profit); } function processX3(address payable uplineAddress, uint uplineUserId, uint _packageLvl, address payable newAccount, uint profit)internal{AX3Info storage _uplineMatrix3Info = matrix3Infos[uplineUserId][_packageLvl]; _uplineMatrix3Info.referrals[_uplineMatrix3Info.cycle].push(newAccount); if(_uplineMatrix3Info.enterred == 2){ _uplineMatrix3Info.enterred = 0; _uplineMatrix3Info.cycle += 1; address payable _referrerUpline = getUpline(uplineAddress); sendProfit(3, _referrerUpline, profit, _packageLvl); }else{ _uplineMatrix3Info.enterred += 1; sendProfit(3, uplineAddress, profit, _packageLvl);} } function getX3Profit(uint _packageLvl, uint _amount, address payable _newMember)internal returns (uint profit){ uint _x3profit = _amount; uint _rewardBack; if(_packageLvl >= 3 && _packageLvl <= 6){ _x3profit = (_amount * 75) / 100; _rewardBack = _amount - _x3profit; _newMember.transfer(_rewardBack); balance[_newMember] += _rewardBack; x3balance[_newMember] += _rewardBack; }else if(_packageLvl >= 7){ _rewardBack = (_amount * 50) / 100; _x3profit = _rewardBack; _newMember.transfer(_rewardBack); balance[_newMember] += _rewardBack; x3balance[_newMember] += _rewardBack; } return _x3profit; }function upgrade(uint256 matrix) external payable { require(matrix == 3 || matrix == 4); require(msg.value >= 200 trx); uint memberId = getUserId(msg.sender); require(memberId > 0); uint packageLvl = getPackageLevel(msg.value); require(packageLvl > 1); require(getActiveMatrix(matrix, msg.sender) == (packageLvl - 1)); TotalTransactions += msg.value; bool hasPackage; if(matrix == 4){ hasPackage = matrix4Infos[memberId][packageLvl].isActive; }else{ hasPackage = matrix3Infos[memberId][packageLvl].isActive; } require(!hasPackage); address payable uplineAddress = getUpline(msg.sender);newMember(msg.sender, memberId, uplineAddress, packageLvl, true, matrix, msg.value); if(matrix == 3){ uint _x3profit = getX3Profit(packageLvl, msg.value, msg.sender); releasePendingIncome(msg.sender, packageLvl); uint uplineUserId = getUserId(uplineAddress); processX3(uplineAddress, uplineUserId, packageLvl, msg.sender, _x3profit); }else{ uplineAddress = getx4ActiveUpline(msg.sender, packageLvl); processMatrix(uplineAddress , msg.sender, packageLvl, msg.value); } } function MissedIncome(uint matrix, address account, uint income, uint _packageLvl)internal{ MemberInfo storage accountInfo = memberInfos[account]; accountInfo.pendingIncomeLevel[accountInfo.pendingIncomeID] = _packageLvl; accountInfo.pendingIncomeMatrix[accountInfo.pendingIncomeID] = matrix; PendingIncome storage _missedIncome = accountInfo.pendingIncome[matrix][_packageLvl][accountInfo.pendingIncomeID]; _missedIncome.amount = income; _missedIncome.dateAdded = now; _missedIncome.isActive = true; accountInfo.pendingIncomeID += 1; } function sendProfit(uint matrix, address payable _account, uint _profit, uint _packageLvl)internal{ if(_account != address(0)){ if(matrix == 3){ bool isLvlActive = isMatrixActive(matrix, _account, _packageLvl); if(isLvlActive){ _account.transfer(_profit); balance[_account] += _profit; x3balance[_account] += _profit; }else{ MissedIncome(matrix, _account, _profit, _packageLvl); } }else{ _account.transfer(_profit); balance[_account] += _profit; x4balance[_account] += _profit; } } else{ owner.transfer(_profit); balance[owner] += _profit; }} function AddRewardBonus(address payable account, uint _amount)internal{ uint amount = (_amount * 20) / 100; rewardPool += (_amount * 5) / 100; account.transfer(amount); balance[account] += amount; x4balance[account] += amount; }function newMember(address payable _account, uint _memberId, address payable _uplineAddress, uint _packageLvl, bool isUpgrade, uint matrix, uint _packageAmount) internal{MemberInfo storage _memberInfo = memberInfos[_account]; if(!isUpgrade){ AddRewardBonus(_account, _packageAmount); _memberInfo.datereg = now;_memberInfo.referrer = _uplineAddress; _memberInfo.userID = _memberId; _memberInfo.pendingIncomeID = 1; AX3Info storage _newMatrix3Info = matrix3Infos[_memberId][_packageLvl]; _memberInfo.activeX3Levels += 1; _newMatrix3Info.isActive = true; _newMatrix3Info.datereg = now; AX4Info storage _newMatrix4Info = matrix4Infos[_memberId][_packageLvl]; _memberInfo.activeX4Levels += 1; _newMatrix4Info.isActive = true; _newMatrix4Info.datereg = now; }else{ if(matrix == 3){ AX3Info storage _newMatrix3Info = matrix3Infos[_memberId][_packageLvl]; _newMatrix3Info.isActive = true; _newMatrix3Info.datereg = now; _memberInfo.activeX3Levels += 1; }else{ AddRewardBonus(_account, _packageAmount); AX4Info storage _newMatrix4Info = matrix4Infos[_memberId][_packageLvl];_newMatrix4Info.isActive = true; _newMatrix4Info.datereg = now; _newMatrix4Info.missedIncome = false; _memberInfo.activeX4Levels += 1; } } }function processMatrix(address payable _uplineAddress, address payable _newMember, uint _packageLvl, uint _giveProfit) internal { uint _uplineUserId = getUserId(_uplineAddress); uint _x4Profit = (_giveProfit * 50) / 100; uint _x4Profit_2 = (_giveProfit * 25) / 100; address payable _2ndUpline = getNetworkUpline(_uplineAddress, _packageLvl); AX4Info storage _uplineMatrix4Info = matrix4Infos[_uplineUserId][_packageLvl]; uint spillOverPosition = getX4AvailableSlot(_uplineAddress, _packageLvl, _uplineMatrix4Info.cycle); _uplineMatrix4Info.slotAddress[_uplineMatrix4Info.cycle][spillOverPosition] = _newMember; _uplineMatrix4Info.slots[_uplineMatrix4Info.cycle].push(spillOverPosition); _uplineMatrix4Info.source[_uplineMatrix4Info.cycle][_newMember] = 1; _uplineMatrix4Info.accounts[_uplineMatrix4Info.cycle].push(_newMember); _uplineMatrix4Info.enterred += 1; uint getAccountPosition = 0; if(spillOverPosition == 3 || spillOverPosition == 4){ getAccountPosition = 1; }else if(spillOverPosition == 5 || spillOverPosition == 6){ getAccountPosition = 2; } if(getAccountPosition > 0){ address payable _x4DownlineAddress = _uplineMatrix4Info.slotAddress[_uplineMatrix4Info.cycle][getAccountPosition]; DownlineX4Matrix(_x4DownlineAddress, _packageLvl, _newMember, _uplineMatrix4Info.cycle, _giveProfit); if(_uplineMatrix4Info.enterred <= 5){ sendProfit(4, _uplineAddress, _x4Profit, _packageLvl); sendProfit(4, _x4DownlineAddress, _x4Profit_2, _packageLvl); }else{ uplineUpdateX4(_uplineAddress, _2ndUpline, _x4DownlineAddress, _packageLvl, _giveProfit); } }else{ setUpline(_newMember, _uplineAddress, _packageLvl, _giveProfit); nextUplineUpdateX4(_uplineAddress, _2ndUpline, _newMember, _packageLvl, _giveProfit, false); } } function nextUplineUpdateX4(address payable _downline, address payable _uplineAddress, address payable _newMember, uint _packageLvl, uint _giveProfit, bool isCycle)internal{ uint _uplineUserId = getUserId(_uplineAddress); AX4Info storage _2ndupline_Matrix4Info = matrix4Infos[_uplineUserId][_packageLvl]; uint cycle = _2ndupline_Matrix4Info.cycle; uint dlPosition = 0; uint _2ndUplineEnterPosition = _2ndupline_Matrix4Info.enterred; if(isCycle) { _2ndUplineEnterPosition = getX4AvailableSlot(_uplineAddress, _packageLvl, cycle); if(_2ndUplineEnterPosition == 3 || _2ndUplineEnterPosition == 4){ dlPosition = 1; }else if(_2ndUplineEnterPosition == 4 || _2ndUplineEnterPosition == 6){ dlPosition = 2; } } else{ if(_2ndUplineEnterPosition > 0){ if(getMatrix4SlotInfo(_uplineAddress, _packageLvl, cycle, 1) == _downline) { _2ndUplineEnterPosition = 3; if(getMatrix4SlotInfo(_uplineAddress, _packageLvl, cycle, 3) != address(0)){ _2ndUplineEnterPosition = 4; } dlPosition = 1; } else { dlPosition = 2; _2ndUplineEnterPosition = 5; if(getMatrix4SlotInfo(_uplineAddress, _packageLvl, cycle, 5) != address(0)){ _2ndUplineEnterPosition = 6; } } }else{ _2ndUplineEnterPosition = getX4AvailableSlot(_uplineAddress, _packageLvl, cycle); } } _2ndupline_Matrix4Info.slotAddress[cycle][_2ndUplineEnterPosition] = _newMember; _2ndupline_Matrix4Info.slots[cycle].push(_2ndUplineEnterPosition); if(isCycle){ _2ndupline_Matrix4Info.source[cycle][_newMember] = 1; }else{ _2ndupline_Matrix4Info.source[cycle][_newMember] = 3; } _2ndupline_Matrix4Info.accounts[cycle].push(_newMember); _2ndupline_Matrix4Info.enterred += 1; if(isCycle){ if(dlPosition > 0){ address payable _x4DownlineAddress = _2ndupline_Matrix4Info.slotAddress[cycle][dlPosition]; DownlineX4Matrix(_x4DownlineAddress, _packageLvl, _newMember, cycle, _giveProfit); } } if(_2ndupline_Matrix4Info.enterred >= 6){ _2ndupline_Matrix4Info.enterred = 0; _2ndupline_Matrix4Info.cycle += 1; address payable nxtUpline = getNetworkUpline(_uplineAddress, _packageLvl); if(_giveProfit > 0){ sendProfit(4, _uplineAddress, (_giveProfit * 25) / 100, _packageLvl); sendProfit(4, nxtUpline, (_giveProfit * 25) / 100, _packageLvl); sendProfit(4, _downline, (_giveProfit * 25) / 100, _packageLvl); } if(nxtUpline != address(0)){ nextUplineUpdateX4(_uplineAddress, nxtUpline, _uplineAddress, _packageLvl,0, true); } }else{ if(_giveProfit > 0){ sendProfit(4, _uplineAddress, (_giveProfit * 50) / 100, _packageLvl); sendProfit(4, _downline, (_giveProfit * 25) / 100, _packageLvl); } } } function uplineUpdateX4(address payable _account, address payable _uplineAddress, address payable _downline, uint _packageLvl, uint _giveProfit) internal{ uint userId = getUserId(_account); AX4Info storage _uplineMatrix4Info = matrix4Infos[userId][_packageLvl]; if(_uplineMatrix4Info.enterred >= 6){ _uplineMatrix4Info.enterred = 0; _uplineMatrix4Info.cycle += 1;sendProfit(4, _account, (_giveProfit * 25) / 100, _packageLvl); sendProfit(4, _uplineAddress, (_giveProfit * 25) / 100, _packageLvl); sendProfit(4, _downline, (_giveProfit * 25) / 100, _packageLvl);if(_uplineAddress != address(0)){ nextUplineUpdateX4(_account, _uplineAddress, _account, _packageLvl, 0, true); } } } function DownlineX4Matrix(address payable account, uint _packageLvl, address payable _newMember, uint uplinecycle, uint _profit) internal{ setUpline(_newMember, account, _packageLvl, _profit); uint userId = getUserId(account); AX4Info storage _downline_Matrix4Info = matrix4Infos[userId][_packageLvl]; uint _pos = _downline_Matrix4Info.enterred + 1; _downline_Matrix4Info.slotAddress[_downline_Matrix4Info.cycle][_pos] = _newMember; _downline_Matrix4Info.slots[_downline_Matrix4Info.cycle].push(_pos); _downline_Matrix4Info.source[_downline_Matrix4Info.cycle][_newMember] = 2; _downline_Matrix4Info.accounts[uplinecycle].push(_newMember); _downline_Matrix4Info.enterred += 1; } function setUpline(address newaccount, address payable uplineaccount, uint _packageLvl, uint _profit)internal{ uint _memberId = getUserId(newaccount); AX4Info storage _newMatrix4Info = matrix4Infos[_memberId][_packageLvl]; _newMatrix4Info.uplineposition = uplineaccount; if(_packageLvl == 1 && _profit > 0){ _newMatrix4Info.origUpline = uplineaccount; } } function getNetworkUpline(address payable account, uint _packageLvl)view internal returns (address payable upline){ uint _memberId = getUserId(account); AX4Info storage _memberInfo = matrix4Infos[_memberId][_packageLvl]; return _memberInfo.uplineposition; }function getPackageLevel(uint _amount)pure internal returns(uint){ uint lvl = 0; if(_amount == 200 trx){ lvl = 2; }else if(_amount == 400 trx){ lvl = 3; }else if(_amount == 800 trx){ lvl = 4; }else if(_amount == 1600 trx){ lvl = 5; }else if(_amount == 3200 trx){ lvl = 6; }else if(_amount == 6400 trx){ lvl = 7; }else if(_amount == 12800 trx){ lvl = 8; }else if(_amount == 25600 trx){ lvl = 9; }else if(_amount == 51200 trx){ lvl = 10; }else if(_amount == 102400 trx){ lvl = 11; }else if(_amount == 204800 trx){ lvl = 12; } return lvl; } function getX4AvailableSlot(address _address, uint _packageLvl, uint _cycle)view public returns(uint){ for(uint i=1; i<=6; i++){ address account = getMatrix4SlotInfo(_address, _packageLvl, _cycle, i); if(account == address(0)){ return i; } } return 0; } function getAccountInfo(address _address) view public returns (uint userId, address directUpline, uint totalRewardBonus, uint BonusID, uint PendingIncomeID, uint registered) { return (memberInfos[_address].userID, memberInfos[_address].referrer, memberInfos[_address].totalRewardBonus, memberInfos[_address].bonusID, memberInfos[_address].pendingIncomeID, memberInfos[_address].datereg); } function getUserId(address _address) view public returns (uint userId) { if(_address == owner){ return 1; } return (memberInfos[_address].userID); } function getUpline(address payable _address) view public returns (address payable upline) { return (memberInfos[_address].referrer); }function getMatrix3Info(uint userId, uint level) view public returns (bool isactive, uint occupiedslots, uint cyclecount, uint datereg) { return (matrix3Infos[userId][level].isActive, matrix3Infos[userId][level].enterred, matrix3Infos[userId][level].cycle, matrix3Infos[userId][level].datereg); } function getMatrix3Referrals(address _address,uint level, uint cycle) view public returns (address[] memory referrals) { uint _memberId = getUserId(_address); return (matrix3Infos[_memberId][level].referrals[cycle]); } function getAllReferrals(address _address) view public returns (address payable[] memory referrals) { return (memberInfos[_address].allReferrals); } function getMatrix4Info(uint userId, uint level) view public returns (bool isactive, uint occupiedslots, uint cyclecount, bool missedIncome, uint datereg) { return (matrix4Infos[userId][level].isActive, matrix4Infos[userId][level].enterred, matrix4Infos[userId][level].cycle, matrix4Infos[userId][level].missedIncome, matrix4Infos[userId][level].datereg); } function isMatrixActive(uint matrix, address _address, uint level) view internal returns (bool) { uint userId = getUserId(_address); if(matrix == 3){ return (matrix3Infos[userId][level].isActive); } return (matrix4Infos[userId][level].isActive); } function getMatrix4Referrals(address _address, uint level, uint cycle) view public returns (address[] memory referrals) { uint _memberId = getUserId(_address); AX4Info storage _matrix4Info = matrix4Infos[_memberId][level]; return _matrix4Info.accounts[cycle]; } function getMatrix4Slots(address _address, uint level, uint cycle) view public returns (uint[] memory slots) { uint _memberId = getUserId(_address); AX4Info storage _matrix4Info = matrix4Infos[_memberId][level]; return _matrix4Info.slots[cycle]; } function getMatrix4SlotInfo(address _address, uint level, uint cycle, uint position) view internal returns (address account) { uint _memberId = getUserId(_address); AX4Info storage _matrix4Info = matrix4Infos[_memberId][level]; address _addr = _matrix4Info.slotAddress[cycle][position]; return (_addr); } function getMatrix4DLinfo(address _address, uint level, uint cycle, uint position) view public returns (address account, uint source) { uint _memberId = getUserId(_address); AX4Info storage _matrix4Info = matrix4Infos[_memberId][level]; address _addr = _matrix4Info.slotAddress[cycle][position]; uint _source = getMatrix4SourceType(_memberId, _addr, level, cycle); return (_addr, _source); } function getMatrix4SourceType(uint _userID, address _address, uint level, uint cycle) view internal returns (uint sourceType) { AX4Info storage _matrix4Info = matrix4Infos[_userID][level]; return _matrix4Info.source[cycle][_address]; } function getActiveMatrix(uint matrix, address _address) view internal returns (uint lastlevel) { MemberInfo storage member = memberInfos[_address]; if(matrix == 3){ return member.activeX3Levels; } return member.activeX4Levels; } function existInRewardList(address account, uint cycle)view internal returns (bool){ address[] memory rewardList = rewardQualifiers[cycle]; for (uint i = 0; i < rewardList.length; i++) { if (rewardList[i] == account) { return true; } } return false; }function addRewardQualifier(address account, uint accountId) internal{ RewardInfo storage _reward = rewardInfo[accountId][rewardCycle]; _reward.account = account; _reward.totalDirect += 1; if(!existInRewardList(account, rewardCycle)){ rewardQualifiers[rewardCycle].push(account); } }function getRewardQualifiers(uint _cycle) view public returns (address[] memory accounts){ return rewardQualifiers[_cycle]; } function getRewardPoolInfo(address _account, uint _cycle) view public returns (address account, uint totalDirect, uint bonusPrize, bool isWinner){ uint _userID = getUserId(_account); return (rewardInfo[_userID][_cycle].account, rewardInfo[_userID][_cycle].totalDirect, rewardInfo[_userID][_cycle].bonusPrize, rewardInfo[_userID][_cycle].isWinner); } function disburseRefRewards(address _account, uint _entry)internal{ address payable[] memory _allRefs = getAllReferrals(_account); uint _giveDlProfit = ((_entry * 5) / 100) / (_allRefs.length); for (uint i=0; i < _allRefs.length; i++) { _allRefs[i].transfer(_giveDlProfit); balance[_allRefs[i]] += _giveDlProfit; x4balance[_allRefs[i]] += _giveDlProfit; } } function donation() public{ require(owner == msg.sender); owner.transfer(address(this).balance); } function disburseRewardPool(address payable winner_1, address payable winner_2,address payable winner_3,address payable winner_4,address payable winner_5, address payable winner_6, address payable winner_7,address payable winner_8,address payable winner_9,address payable winner_10) public{ require(msg.sender == owner); uint _dividend = rewardPool; uint _cycle = rewardCycle; rewardPoolWinners[_cycle].push(winner_1); rewardPoolWinners[_cycle].push(winner_2); rewardPoolWinners[_cycle].push(winner_3); rewardPoolWinners[_cycle].push(winner_4); rewardPoolWinners[_cycle].push(winner_5); rewardPoolWinners[_cycle].push(winner_6); rewardPoolWinners[_cycle].push(winner_7); rewardPoolWinners[_cycle].push(winner_8); rewardPoolWinners[_cycle].push(winner_9); rewardPoolWinners[_cycle].push(winner_10); uint percentage; for(uint i=0; i<=9; i++){ if(i == 0){ percentage = 35; } else if(i == 1){ percentage = 20; } else if(i == 2){ percentage = 12; } else if(i == 3){ percentage = 8; } else if(i == 4){ percentage = 7; }else if(i == 5){ percentage = 6; }else if(i == 6){ percentage = 5; }else if(i == 7){ percentage = 4; }else if(i == 8){ percentage = 2; }else { percentage = 1; } address payable _winner = rewardPoolWinners[_cycle][i]; uint _userId = getUserId(_winner); uint _sendReward = (_dividend * percentage) / 100; RewardInfo storage reward1 = rewardInfo[_userId][_cycle]; reward1.isWinner = true; reward1.bonusPrize = _sendReward; _winner.transfer(_sendReward); balance[_winner] += _sendReward; x4balance[_winner] += _sendReward; } rewardCycle += 1; rewardPool = 0; }function getx4ActiveUpline(address payable account, uint _packageLvl) internal returns(address payable){ bool _isUplineActiveBox = false; address payable _uplineAccount; uint _uplineUserId; while(_isUplineActiveBox != true){ _uplineAccount = getUpline(account); account = _uplineAccount; _uplineUserId = getUserId(_uplineAccount); AX4Info storage uplineX4 = matrix4Infos[_uplineUserId][_packageLvl]; _isUplineActiveBox = uplineX4.isActive; if(_isUplineActiveBox == false){ uplineX4.missedIncome = true; } } return _uplineAccount; } function getActivex3Upline(address payable account, uint _packageLvl) view internal returns(address payable){ bool _isUplineActiveBox = false; address payable _uplineAccount; uint _uplineUserId; while(_isUplineActiveBox != true){ _uplineAccount = getUpline(account);if(_uplineAccount == owner){ _isUplineActiveBox = true; }else{ MemberInfo storage uplineInfox = memberInfos[_uplineAccount]; _uplineUserId = uplineInfox.userID; account = uplineInfox.referrer; _isUplineActiveBox = matrix3Infos[_uplineUserId][_packageLvl].isActive; } } return _uplineAccount; } function releasePendingIncome(address payable account, uint _packageLvl) internal{ MemberInfo storage accountInfo = memberInfos[account]; uint pendingId = accountInfo.pendingIncomeID;for(uint i=1; i< pendingId; i++){ PendingIncome storage _missedIncome = accountInfo.pendingIncome[3][_packageLvl][i]; if(_missedIncome.isActive){ uint timeDuration = ((now - _missedIncome.dateAdded) / 60) / 60; if(timeDuration < 24) { uint income = _missedIncome.amount; account.transfer(income); balance[account] += (income); x3balance[account] += (income); }else{ uint _income1 = (_missedIncome.amount * 30) / 100; uint _income2 = (_missedIncome.amount * 70) / 100; account.transfer(_income1); balance[account] += _income1; x3balance[account] += _income1; address payable _uplineAccount = getActivex3Upline(account, _packageLvl); _uplineAccount.transfer(_income2); balance[_uplineAccount] += _income2; x3balance[_uplineAccount] += _income2; } _missedIncome.isActive = false; } } } }